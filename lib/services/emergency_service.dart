import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../models/emergency.dart';
import '../models/event.dart';
import '../models/resolution_outcome.dart';
import '../services/event_service.dart';
import '../core/logger.dart';

/// Service for managing emergency requests
/// This is the core backend logic - no UI dependencies
class EmergencyService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final EventService _eventService = EventService();

  static const String _collectionName = 'emergencies';

  /// Create a new emergency request
  /// This is the primary method that closes the "Air Gap"
  Future<Emergency> createEmergency({
    required GeoPoint location,
    required EmergencyUrgency urgency,
    String? description,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final user = _auth.currentUser;
      if (user == null) {
        throw Exception('User must be authenticated to create emergency');
      }

      AppLogger.i('Creating emergency for user: ${user.uid}');

      // Get user profile for name
      String? patientName;
      try {
        final userDoc = await _firestore.collection('users').doc(user.uid).get();
        if (userDoc.exists) {
          final userData = userDoc.data();
          patientName = userData?['name'] as String?;
        }
      } catch (e) {
        AppLogger.w('Could not fetch user name: $e');
      }

      final timestamp = DateTime.now();
      final emergency = Emergency(
        id: '', // Will be generated by Firestore
        patientId: user.uid,
        patientName: patientName,
        timestamp: timestamp,
        location: location,
        urgency: urgency,
        status: EmergencyStatus.created,
        description: description,
        metadata: metadata,
      );

      // Create emergency document in Firestore
      final docRef = await _firestore
          .collection(_collectionName)
          .add(emergency.toFirestore());

      AppLogger.i('Emergency created with ID: ${docRef.id}');

      // Log the event (append-only audit trail)
      await _eventService.logEvent(
        type: EventType.emergencyCreated,
        emergencyId: docRef.id,
        data: {
          'urgency': urgency.toString().split('.').last,
          'location': {
            'latitude': location.latitude,
            'longitude': location.longitude,
          },
        },
        description: description ?? 'Emergency created',
      );

      // Return the created emergency with the generated ID
      return emergency.copyWith(id: docRef.id);
    } catch (e, stackTrace) {
      AppLogger.e('Failed to create emergency', e, stackTrace);
      // Error will be handled by the caller with context
      rethrow;
    }
  }

  /// Get a specific emergency by ID
  Future<Emergency?> getEmergency(String emergencyId) async {
    try {
      final doc = await _firestore.collection(_collectionName).doc(emergencyId).get();
      if (!doc.exists) {
        return null;
      }
      return Emergency.fromFirestore(doc);
    } catch (e, stackTrace) {
      AppLogger.e('Failed to get emergency: $emergencyId', e, stackTrace);
      return null;
    }
  }

  /// Stream of a specific emergency (for real-time updates)
  Stream<Emergency?> streamEmergency(String emergencyId) {
    return _firestore
        .collection(_collectionName)
        .doc(emergencyId)
        .snapshots()
        .map((doc) => doc.exists ? Emergency.fromFirestore(doc) : null);
  }

  /// Get all emergencies for the current user
  Stream<List<Emergency>> getUserEmergencies() {
    final user = _auth.currentUser;
    if (user == null) {
      return Stream.value([]);
    }

    return _firestore
        .collection(_collectionName)
        .where('patientId', isEqualTo: user.uid)
        .orderBy('timestamp', descending: true)
        .snapshots()
        .map((snapshot) =>
            snapshot.docs.map((doc) => Emergency.fromFirestore(doc)).toList());
  }

  /// Update emergency status
  Future<void> updateEmergencyStatus(
    String emergencyId,
    EmergencyStatus newStatus, {
    String? assignedFacilityId,
    String? assignedDriverId,
    String? resolutionOutcome,
  }) async {
    try {
      final updateData = <String, dynamic>{
        'status': newStatus.toString().split('.').last,
      };

      final now = DateTime.now();

      // Set timestamps based on status
      switch (newStatus) {
        case EmergencyStatus.dispatched:
          updateData['dispatchedAt'] = Timestamp.fromDate(now);
          if (assignedFacilityId != null) {
            updateData['assignedFacilityId'] = assignedFacilityId;
          }
          break;
        case EmergencyStatus.inTransit:
          updateData['inTransitAt'] = Timestamp.fromDate(now);
          if (assignedDriverId != null) {
            updateData['assignedDriverId'] = assignedDriverId;
          }
          break;
        case EmergencyStatus.arrived:
          updateData['arrivedAt'] = Timestamp.fromDate(now);
          break;
        case EmergencyStatus.resolved:
          updateData['resolvedAt'] = Timestamp.fromDate(now);
          if (resolutionOutcome != null) {
            updateData['resolutionOutcome'] = resolutionOutcome;
          }
          break;
        default:
          break;
      }

      await _firestore
          .collection(_collectionName)
          .doc(emergencyId)
          .update(updateData);

      AppLogger.i('Emergency $emergencyId status updated to: ${newStatus.toString().split('.').last}');

      // Log the event
      EventType? eventType;
      switch (newStatus) {
        case EmergencyStatus.dispatched:
          eventType = EventType.emergencyDispatched;
          break;
        case EmergencyStatus.inTransit:
          eventType = EventType.emergencyInTransit;
          break;
        case EmergencyStatus.arrived:
          eventType = EventType.emergencyArrived;
          break;
        case EmergencyStatus.resolved:
          eventType = EventType.emergencyResolved;
          break;
        case EmergencyStatus.cancelled:
          eventType = EventType.emergencyCancelled;
          break;
        default:
          break;
      }

      if (eventType != null) {
        await _eventService.logEvent(
          type: eventType,
          emergencyId: emergencyId,
          entityId: assignedFacilityId ?? assignedDriverId,
          description: 'Emergency status changed to ${newStatus.toString().split('.').last}',
        );
      }
    } catch (e, stackTrace) {
      AppLogger.e('Failed to update emergency status: $emergencyId', e, stackTrace);
      // Error will be handled by the caller with context
      rethrow;
    }
  }

  /// Cancel an emergency
  Future<void> cancelEmergency(String emergencyId) async {
    await updateEmergencyStatus(emergencyId, EmergencyStatus.cancelled);
  }

  /// Resolve an emergency with outcome (Week 4)
  Future<void> resolveEmergency(
    String emergencyId,
    ResolutionOutcome outcome, {
    String? notes,
  }) async {
    try {
      final user = _auth.currentUser;
      if (user == null) {
        throw Exception('User must be authenticated to resolve emergency');
      }

      final updateData = <String, dynamic>{
        'status': EmergencyStatus.resolved.toString().split('.').last,
        'resolvedAt': Timestamp.fromDate(DateTime.now()),
        'resolutionOutcome': outcome.value,
      };

      if (notes != null && notes.isNotEmpty) {
        updateData['resolutionNotes'] = notes;
      }

      await _firestore
          .collection(_collectionName)
          .doc(emergencyId)
          .update(updateData);

      AppLogger.i('Emergency $emergencyId resolved with outcome: ${outcome.displayName}');

      // Log the resolution event
      await _eventService.logEvent(
        type: EventType.emergencyResolved,
        emergencyId: emergencyId,
        entityId: user.uid,
        data: {
          'outcome': outcome.value,
          if (notes != null) 'notes': notes,
        },
        description: 'Emergency resolved: ${outcome.displayName}',
      );

      // If driver was assigned, release them
      final emergencyDoc = await _firestore.collection(_collectionName).doc(emergencyId).get();
      if (emergencyDoc.exists) {
        final emergencyData = emergencyDoc.data();
        final driverId = emergencyData?['assignedDriverId'] as String?;
        if (driverId != null) {
          try {
            await _firestore.collection('drivers').doc(driverId).update({
              'status': 'available',
              'updatedAt': FieldValue.serverTimestamp(),
            });
            AppLogger.i('Driver $driverId released after emergency resolution');
          } catch (e) {
            AppLogger.w('Could not release driver: $e');
          }
        }
      }
    } catch (e, stackTrace) {
      AppLogger.e('Failed to resolve emergency: $emergencyId', e, stackTrace);
      rethrow;
    }
  }

  /// Calculate emergency response metrics (Week 4)
  Map<String, Duration?> calculateMetrics(Emergency emergency) {
    return {
      'timeToDispatch': emergency.dispatchedAt != null
          ? emergency.dispatchedAt!.difference(emergency.timestamp)
          : null,
      'timeToArrival': emergency.arrivedAt != null && emergency.inTransitAt != null
          ? emergency.arrivedAt!.difference(emergency.inTransitAt!)
          : null,
      'timeToResolution': emergency.resolvedAt != null
          ? emergency.resolvedAt!.difference(emergency.timestamp)
          : null,
      'totalResponseTime': emergency.arrivedAt != null
          ? emergency.arrivedAt!.difference(emergency.timestamp)
          : null,
    };
  }

  /// Get emergency timeline (all events for an emergency)
  Future<List<Event>> getEmergencyTimeline(String emergencyId) async {
    try {
      final eventsSnapshot = await _firestore
          .collection('events')
          .where('emergencyId', isEqualTo: emergencyId)
          .orderBy('timestamp', descending: false)
          .get();

      return eventsSnapshot.docs
          .map((doc) => Event.fromFirestore(doc))
          .toList();
    } catch (e, stackTrace) {
      AppLogger.e('Failed to get emergency timeline: $emergencyId', e, stackTrace);
      return [];
    }
  }
}

